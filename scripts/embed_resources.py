#!/usr/bin/env python3

import os
import sys
from pathlib import Path

def sanitize_name(name):
    """Convert a filename to a valid C++ identifier."""
    result = name.replace('.', '_').replace('-', '_').replace(' ', '_')
    if result[0].isdigit():
        result = '_' + result
    return result

def generate_resource_files(resources_dir, header_file, source_file):
    """Generate header and source files with embedded resources."""
    
    resources = []
    
    resource_dirs = ['shaders', 'environments', 'material', 'models', 'resources', 'ui']
    
    for subdir in resource_dirs:
        subdir_path = resources_dir / subdir
        if not subdir_path.exists():
            continue
            
        for root, dirs, files in os.walk(subdir_path):
            for filename in files:
                filepath = Path(root) / filename
                if filepath.suffix in ['.cpp', '.c', '.h', '.hpp']:
                    continue
                    
                rel_path = filepath.relative_to(resources_dir)
                resources.append((rel_path, filepath))
    
    source_dir = Path(source_file).parent.resolve()
    resources_dir_resolved = resources_dir.resolve()
    with open(header_file, 'w') as f:
        f.write('''// Auto-generated embedded resources header - DO NOT EDIT
// Generated by embed_resources.py

#pragma once
#include <cstddef>
#include <string>

namespace EmbeddedResources {

struct Resource {
    const unsigned char* data;
    const unsigned int* size;
};

// Get an embedded resource by path (e.g., "shaders/main.vert")
// Returns nullptr if not found
const Resource* getResource(const std::string& path);

} // namespace EmbeddedResources
''')
    
    # Generate the source file with incbin
    with open(source_file, 'w') as f:
        f.write('''// Auto-generated embedded resources - DO NOT EDIT
// Generated by embed_resources.py

#include "embedded_resources.h"
#include <unordered_map>

// Configure incbin
#define INCBIN_PREFIX g_
#define INCBIN_STYLE INCBIN_STYLE_SNAKE
#include <incbin/incbin.h>

''')
        
        # Generate INCBIN declarations for each resource
        # Use paths relative to the source file location
        for rel_path, filepath in resources:
            var_name = sanitize_name(str(rel_path).replace('\\', '_').replace('/', '_'))
            # Path relative to source file - just use the relative path from src/
            inc_path = str(rel_path).replace('\\', '/')
            f.write(f'INCBIN({var_name}, "{inc_path}");\n')
        
        f.write('''
namespace EmbeddedResources {

const Resource* getResource(const std::string& path) {
    // Normalize path separators
    std::string normalizedPath = path;
    for (char& c : normalizedPath) {
        if (c == '\\\\') c = '/';
    }
    // Remove leading slash if present
    if (!normalizedPath.empty() && normalizedPath[0] == '/') {
        normalizedPath = normalizedPath.substr(1);
    }
    
    static const std::unordered_map<std::string, Resource> resources = {
''')
        
        for rel_path, filepath in resources:
            var_name = sanitize_name(str(rel_path).replace('\\', '_').replace('/', '_'))
            lookup_key = str(rel_path).replace('\\', '/')
            f.write(f'        {{"{lookup_key}", {{g_{var_name}_data, &g_{var_name}_size}}}},\n')
        
        f.write('''    };
    
    auto it = resources.find(normalizedPath);
    if (it != resources.end()) {
        return &it->second;
    }
    return nullptr;
}

} // namespace EmbeddedResources
''')
    
    print(f"Generated {header_file} and {source_file} with {len(resources)} embedded resources")
    
    total_size = sum(filepath.stat().st_size for _, filepath in resources)
    print(f"Total embedded size: {total_size / (1024*1024):.2f} MB")

if __name__ == '__main__':
    if len(sys.argv) < 4:
        print(f"Usage: {sys.argv[0]} <resources_dir> <output_header> <output_source>")
        sys.exit(1)
    
    resources_dir = Path(sys.argv[1])
    header_file = Path(sys.argv[2])
    source_file = Path(sys.argv[3])
    
    generate_resource_files(resources_dir, header_file, source_file)
